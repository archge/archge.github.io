== 第 1 章  *Vim解决问题的方式* ==

===tip1 认识 . 命令===

	`.`命令可以让我们重复上次的修改，他是Vim中最为强大的多面手。
    
	这是Vim区分模式的编辑模型如此高效的核心原因，究竟什么是修改？
	
	`x`命令会删除光标下的字符，再次使用`.`命令“重复上次修改”时，就会删除光标下的字符。`u`命令撤销上次的修改。
	
	`dd`命令删除整行。 
	
	`>G`命令会增加当前行到文档末尾处的缩进层级。
	
	*注意：* 从进入INSERT模式那一刻（输入`i`），直到返回NORMAL模式为止（输入`<Esc>`），Vim会记录每一个按键操作，从`i`到`<Esc>`。做出这样一个修改后再用`.`命令，将会重新执行这一系列按键操作。
	
	`.`命令是一个微内宏（macro）。

===tip2 不要自我重复===

	`a`在当前光标之后添加内容，`A`在当前行结尾添加内容，`$`移动到当前行结尾。那么在当前行结尾处添加冒号：`$a:<Esc>`，若要在下一行重复操作`j$.`。也就是说，`.`封装了`a;<Esc>`，当然也可以使用`A;<Esc>`。
	
	| 复合命令 | 等效的长命令 |
	|----------|--------------|
	| `C`      | `c$`         |
	| `s`      | `cl`         |
	| `S`      | `^C`         |
	| `l`      | `^i`         |
	| `A`      | `$a`         |
	| `o`      | `A<CR>`      |
	| `O`      | `ko`         |
	             
	以上命令都有个共同的特点，它们都会从普通模式切换到插入模式。
	
===tip3 以退为进===

{{{
 var foo = 'method("+argument+")';
}}}

	如果要在上述代码中+号前后各加一个空格，可采用下述方法。
	# `f+` ：查找下一处指定字符出现的位置。`f{char}`
	# `s_+_<Esc>` ：`s`先删除光标下字符，然后进入插入模式；`_`表示空格。这时`.`命令会记录该动作。
	# `;` ：重复上一次`f`命令所查找的字符。
	# `.` ：重复第二步。

	以上，先后退一小步删除字符，然后前进三步，这样的好处是能够使用范式`.`。
	
===tip4 执行、重复、回退===

	| 目的                     | 操作                 | 重复 | 回退 |
	|--------------------------|----------------------|------|------|
	| 做出一个修改             | {edit}               | `.`  | `u`  |
	| 在行内查找下一指定字符   | `f{char}`/`t{char}`  | `;`  | `,`  |
	| 在行内查找上一个字符     | `F{char}`/`T{char}`  | `;`  | `,`  |
	| 在文档中查找下一处匹配项 | /pattern`<CR>`       | `n`  | `N`  |
	| 在文档中查找上一处匹配项 | ?pattern`<CR>`       | `n`  | `N`  |
	| 执行替换                 | :s/target/replacment | `&`  | `u`  |
	| 执行一系列修改           | `qx{changes}q`       | `@x` | `u`  |
	
===tip5 查找并手动替换===

	如果想用单词copy替换content，可用如下命令
	
{{{
 :%s/content/copy/g
}}}
	
	但是这会替换所有的content，如果我们只要替换其中的一些怎么办？
	
	偷懒的办法：`*`命令，查找当前光标下的单词，如果要高亮显示，设置:set hls。配合`cw`命令会删除从光标位置到单词结尾间的字符，并进入插入模式，接下来输入单词copy就可以了。Vim会把离开插入模式之前的全部按键操作都记录下来，因此整个`cw``copy<Esc>`会被当成一个修改。
	
	如果要继续修改下一处的content，只需按键`n.`即可完成操作。
