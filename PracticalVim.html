<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>PracticalVim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="第 1 章  *Vim解决问题的方式*"><h2 id="第 1 章  *Vim解决问题的方式*" class="header"><a href="#第 1 章  *Vim解决问题的方式*">第 1 章  <span id="第 1 章  *Vim解决问题的方式*-Vim解决问题的方式"></span><strong id="Vim解决问题的方式">Vim解决问题的方式</strong></a></h2></div>

<div id="第 1 章  *Vim解决问题的方式*-tip1 认识 . 命令"><h3 id="tip1 认识 . 命令" class="header"><a href="#第 1 章  *Vim解决问题的方式*-tip1 认识 . 命令">tip1 认识 . 命令</a></h3></div>

<p>
	<code>.</code>命令可以让我们重复上次的修改，他是Vim中最为强大的多面手。
</p>
    
<p>
	这是Vim区分模式的编辑模型如此高效的核心原因，究竟什么是修改？
</p>
	
<p>
	<code>x</code>命令会删除光标下的字符，再次使用<code>.</code>命令“重复上次修改”时，就会删除光标下的字符。<code>u</code>命令撤销上次的修改。
</p>
	
<p>
	<code>dd</code>命令删除整行。 
</p>
	
<p>
	<code>&gt;G</code>命令会增加当前行到文档末尾处的缩进层级。
</p>
	
<p>
	<span id="第 1 章  *Vim解决问题的方式*-tip1 认识 . 命令-注意："></span><strong id="注意：">注意：</strong> 从进入INSERT模式那一刻（输入<code>i</code>），直到返回NORMAL模式为止（输入<code>&lt;Esc&gt;</code>），Vim会记录每一个按键操作，从<code>i</code>到<code>&lt;Esc&gt;</code>。做出这样一个修改后再用<code>.</code>命令，将会重新执行这一系列按键操作。
</p>
	
<p>
	<code>.</code>命令是一个微内宏（macro）。
</p>

<div id="第 1 章  *Vim解决问题的方式*-tip2 不要自我重复"><h3 id="tip2 不要自我重复" class="header"><a href="#第 1 章  *Vim解决问题的方式*-tip2 不要自我重复">tip2 不要自我重复</a></h3></div>

<p>
	<code>a</code>在当前光标之后添加内容，<code>A</code>在当前行结尾添加内容，<code>\(</code>移动到当前行结尾。那么在当前行结尾处添加冒号：<code>\)a:&lt;Esc&gt;</code>，若要在下一行重复操作<code>j$.</code>。也就是说，<code>.</code>封装了<code>a;&lt;Esc&gt;</code>，当然也可以使用<code>A;&lt;Esc&gt;</code>。
</p>
	
<table class='center'>
<tr>
<th>
复合命令
</th>
<th>
等效的长命令
</th>
</tr>
<tr>
<td>
<code>C</code>
</td>
<td>
<code>c$</code>
</td>
</tr>
<tr>
<td>
<code>s</code>
</td>
<td>
<code>cl</code>
</td>
</tr>
<tr>
<td>
<code>S</code>
</td>
<td>
<code>^C</code>
</td>
</tr>
<tr>
<td>
<code>l</code>
</td>
<td>
<code>^i</code>
</td>
</tr>
<tr>
<td>
<code>A</code>
</td>
<td>
<code>$a</code>
</td>
</tr>
<tr>
<td>
<code>o</code>
</td>
<td>
<code>A&lt;CR&gt;</code>
</td>
</tr>
<tr>
<td>
<code>O</code>
</td>
<td>
<code>ko</code>
</td>
</tr>
</table>
	             
<p>
	以上命令都有个共同的特点，它们都会从普通模式切换到插入模式。
</p>
	
<div id="第 1 章  *Vim解决问题的方式*-tip3 以退为进"><h3 id="tip3 以退为进" class="header"><a href="#第 1 章  *Vim解决问题的方式*-tip3 以退为进">tip3 以退为进</a></h3></div>

<pre>
	var foo = 'method("+argument+")';
</pre>

<p>
	如果要在上述代码中+号前后各加一个空格，可采用下述方法。
</p>
<ol>
<li>
<code>f+</code> ：查找下一处指定字符出现的位置。<code>f{char}</code>

<li>
<code>s_+_&lt;Esc&gt;</code> ：<code>s</code>先删除光标下字符，然后进入插入模式；<code>_</code>表示空格。这时<code>.</code>命令会记录该动作。

<li>
<code>;</code> ：重复上一次<code>f</code>命令所查找的字符。

<li>
<code>.</code> ：重复第二步。

</ol>

<p>
	以上，先后退一小步删除字符，然后前进三步，这样的好处是能够使用范式<code>.</code>。
</p>
	
<div id="第 1 章  *Vim解决问题的方式*-tip4 执行、重复、回退"><h3 id="tip4 执行、重复、回退" class="header"><a href="#第 1 章  *Vim解决问题的方式*-tip4 执行、重复、回退">tip4 执行、重复、回退</a></h3></div>
<table class='center'>
<tr>
<th>
目的
</th>
<th>
操作
</th>
<th>
重复
</th>
<th>
回退
</th>
</tr>
<tr>
<td>
做出一个修改
</td>
<td>
{edit}
</td>
<td>
<code>.</code>
</td>
<td>
<code>u</code>
</td>
</tr>
<tr>
<td>
在行内查找下一指定字符
</td>
<td>
<code>f{char}</code>/<code>t{char}</code>
</td>
<td>
<code>;</code>
</td>
<td>
<code>,</code>
</td>
</tr>
<tr>
<td>
在行内查找上一个字符
</td>
<td>
<code>F{char}</code>/<code>T{char}</code>
</td>
<td>
<code>;</code>
</td>
<td>
<code>,</code>
</td>
</tr>
<tr>
<td>
在文档中查找下一处匹配项
</td>
<td>
/pattern<code>&lt;CR&gt;</code>
</td>
<td>
<code>n</code>
</td>
<td>
<code>N</code>
</td>
</tr>
<tr>
<td>
在文档中查找上一处匹配项
</td>
<td>
?pattern<code>&lt;CR&gt;</code>
</td>
<td>
<code>n</code>
</td>
<td>
<code>N</code>
</td>
</tr>
<tr>
<td>
执行替换
</td>
<td>
:s/target/replacment
</td>
<td>
<code>&amp;</code>
</td>
<td>
<code>u</code>
</td>
</tr>
<tr>
<td>
执行一系列修改
</td>
<td>
<code>qx{changes}q</code>
</td>
<td>
<code>@x</code>
</td>
<td>
<code>u</code>
</td>
</tr>
</table>

</body>
</html>
